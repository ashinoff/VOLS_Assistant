import logging
import io
from functools import lru_cache
from typing import Any, Dict, List, Optional

import pandas as pd
import httpx
import uvicorn
from fastapi import FastAPI, Request
from telegram import (
    Update,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    KeyboardButton,
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)
from config import (
    TOKEN,
    ZONES_CSV_URL,
    SELF_URL,
    PORT,
    # URLs for TP data
    YUGO_ZAPAD_URL_UG,
    CENTRAL_URL_UG,
    ZAPAD_URL_UG,
    VOSTOCH_URL_UG,
    YUZH_URL_UG,
    SEVERO_VOSTOCH_URL_UG,
    YUGO_VOSTOCH_URL_UG,
    SEVER_URL_UG,
    YUGO_ZAPAD_URL_RK,
    UST_LABINSK_URL_RK,
    TIMASHEVSK_URL_RK,
    TIKHORETSK_URL_RK,
    SOCHI_URL_RK,
    SLAVYANSK_URL_RK,
    LENINGRADSK_URL_RK,
    LABINSK_URL_RK,
    KRASNODAR_URL_RK,
    ARMAVIR_URL_RK,
    ADYGEYSK_URL_RK,
    # URLs for notification directory
    YUGO_ZAPAD_URL_UG_SP,
    CENTRAL_URL_UG_SP,
    ZAPAD_URL_UG_SP,
    VOSTOCH_URL_UG_SP,
    YUZH_URL_UG_SP,
    SEVERO_VOSTOCH_URL_UG_SP,
    YUGO_VOSTOCH_URL_UG_SP,
    SEVER_URL_UG_SP,
    YUGO_ZAPAD_URL_RK_SP,
    UST_LABINSK_URL_RK_SP,
    TIMASHEVSK_URL_RK_SP,
    TIKHORETSK_URL_RK_SP,
    SOCHI_URL_RK_SP,
    SLAVYANSK_URL_RK_SP,
    LENINGRADSK_URL_RK_SP,
    LABINSK_URL_RK_SP,
    KRASNODAR_URL_RK_SP,
    ARMAVIR_URL_RK_SP,
    ADYGEYSK_URL_RK_SP,
    # Report files
    NOTIFY_LOG_FILE_UG,
    NOTIFY_LOG_FILE_RK,
)

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# FastAPI app placeholder; Telegram application initialized on startup
app = FastAPI()
application: Application

# Conversation states
(
    SEARCH_TP,
    SELECT_TP,
    NOTIFY_TP,
    NOTIFY_VL,
    NOTIFY_GEO,
    REPORT_MENU,
) = range(6)

# ES URL mappings
ES_URL_MAPPING: Dict[str, str] = {
    "–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°_UG": YUGO_ZAPAD_URL_UG,
    "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –≠–°": CENTRAL_URL_UG,
    "–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°": ZAPAD_URL_UG,
    "–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": VOSTOCH_URL_UG,
    "–Æ–∂–Ω—ã–µ –≠–°": YUZH_URL_UG,
    "–°–µ–≤–µ—Ä–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": SEVERO_VOSTOCH_URL_UG,
    "–Æ–≥–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": YUGO_VOSTOCH_URL_UG,
    "–°–µ–≤–µ—Ä–Ω—ã–µ –≠–°": SEVER_URL_UG,
    "–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°_RK": YUGO_ZAPAD_URL_RK,
    "–£—Å—Ç—å-–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°": UST_LABINSK_URL_RK,
    "–¢–∏–º–∞—à–µ–≤—Å–∫–∏–µ –≠–°": TIMASHEVSK_URL_RK,
    "–¢–∏—Ö–æ—Ä–µ—Ü–∫–∏–µ –≠–°": TIKHORETSK_URL_RK,
    "–°–æ—á–∏–Ω—Å–∫–∏–µ –≠–°": SOCHI_URL_RK,
    "–°–ª–∞–≤—è–Ω—Å–∫–∏–µ –≠–°": SLAVYANSK_URL_RK,
    "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∏–µ –≠–°": LENINGRADSK_URL_RK,
    "–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°": LABINSK_URL_RK,
    "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–µ –≠–°": KRASNODAR_URL_RK,
    "–ê—Ä–º–∞–≤–∏—Ä—Å–∫–∏–µ –≠–°": ARMAVIR_URL_RK,
    "–ê–¥—ã–≥–µ–π—Å–∫–∏–µ –≠–°": ADYGEYSK_URL_RK,
}
ES_SP_URL_MAPPING: Dict[str, str] = {**ES_URL_MAPPING}
ES_SP_URL_MAPPING.update({
    "–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°_UG": YUGO_ZAPAD_URL_UG_SP,
    "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –≠–°": CENTRAL_URL_UG_SP,
    "–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°": ZAPAD_URL_UG_SP,
    "–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": VOSTOCH_URL_UG_SP,
    "–Æ–∂–Ω—ã–µ –≠–°": YUZH_URL_UG_SP,
    "–°–µ–≤–µ—Ä–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": SEVERO_VOSTOCH_URL_UG_SP,
    "–Æ–≥–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": YUGO_VOSTOCH_URL_UG_SP,
    "–°–µ–≤–µ—Ä–Ω—ã–µ –≠–°": SEVER_URL_UG_SP,
    "–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°_RK": YUGO_ZAPAD_URL_RK_SP,
    "–£—Å—Ç—å-–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°": UST_LABINSK_URL_RK_SP,
    "–¢–∏–º–∞—à–µ–≤—Å–∫–∏–µ –≠–°": TIMASHEVSK_URL_RK_SP,
    "–¢–∏—Ö–æ—Ä–µ—Ü–∫–∏–µ –≠–°": TIKHORETSK_URL_RK_SP,
    "–°–æ—á–∏–Ω—Å–∫–∏–µ –≠–°": SOCHI_URL_RK_SP,
    "–°–ª–∞–≤—è–Ω—Å–∫–∏–µ –≠–°": SLAVYANSK_URL_RK_SP,
    "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∏–µ –≠–°": LENINGRADSK_URL_RK_SP,
    "–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°": LABINSK_URL_RK_SP,
    "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–µ –≠–°": KRASNODAR_URL_RK_SP,
    "–ê—Ä–º–∞–≤–∏—Ä—Å–∫–∏–µ –≠–°": ARMAVIR_URL_RK_SP,
    "–ê–¥—ã–≥–µ–π—Å–∫–∏–µ –≠–°": ADYGEYSK_URL_RK_SP,
})

# Main menu
MAIN_MENU = [
    {"text": "‚ö°Ô∏è –†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "vis": "all"},
    {"text": "‚ö°Ô∏è –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å", "vis": "all"},
    {"text": "üìä –í—ã–≥—Ä—É–∑–∏—Ç—å –æ—Ç—á–µ—Ç—ã", "vis": "all"},
    {"text": "üìû –¢–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫", "vis": "all"},
    {"text": "üìñ –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", "vis": "all"},
    {"text": "üìö –°–ø—Ä–∞–≤–∫–∞", "vis": "all"},
    {"text": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "vis": "all"},
]

# Report submenu
REPORT_SUBMENU = [
    {"text": "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –Æ–ì", "vis": "all"},
    {"text": "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –ö—É–±–∞–Ω—å", "vis": "all"},
    {"text": "üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤", "vis": "all"},
    {"text": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "vis": "all"},
]

# Utility: build keyboard based on visibility

def build_menu(
    buttons: List[Dict[str, str]], user_data: Dict[str, Any]
) -> ReplyKeyboardMarkup:
    keyboard = []
    for btn in buttons:
        if has_access(user_data, btn["vis"]):
            keyboard.append([btn["text"]])
    return (
        ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        if keyboard
        else ReplyKeyboardRemove()
    )

# Load and cache user data
@lru_cache(maxsize=1)
def load_user_data() -> Dict[str, Dict[str, Any]]:
    users = {}
    try:
        df = pd.read_csv(ZONES_CSV_URL, encoding="utf-8")
        for _, row in df.iterrows():
            uid = str(row["Telegram ID"])
            users[uid] = {
                "Visibility": row["–í–∏–¥–∏–º–æ—Å—Ç—å"],
                "Branch": row["–§–∏–ª–∏–∞–ª"],
                "RES": row["–†–≠–°"],
                "FIO": row["–§–ò–û"],
                "Responsible": row["–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π"],
            }
    except Exception as e:
        logger.error(f"Error loading user data: {e}")
    return users

# Access check

def has_access(user_data: Dict[str, Any], required_vis: str) -> bool:
    if not user_data:
        return False
    uv = user_data.get("Visibility", "").lower()
    return uv == "all" or required_vis == "all" or uv == required_vis.lower()

# ... (other utility functions: load_tp_data, load_tp_directory_data, fuzzy_search_tp, find_responsible) ...

# Handlers
async def start(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    uid = str(update.effective_user.id)
    ud = load_user_data().get(uid)
    if not ud:
        await update.message.reply_text(
            "üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=ReplyKeyboardRemove()
        )
        return ConversationHandler.END
    context.user_data.clear()
    context.user_data.update({"state": "MAIN_MENU"})
    await update.message.reply_text(
        f"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {ud['FIO']}! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=build_menu(MAIN_MENU, ud),
    )
    return ConversationHandler.END

async def handle_message(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    uid = str(update.effective_user.id)
    ud = load_user_data().get(uid)
    if not ud:
        await update.message.reply_text(
            "üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=ReplyKeyboardRemove()
        )
        return ConversationHandler.END
    text = update.message.text
    state = context.user_data.get("state", "MAIN_MENU")

    # MAIN_MENU
    if state == "MAIN_MENU":
        if text == "‚ö°Ô∏è –†–æ—Å—Å–µ—Ç–∏ –Æ–ì":
            context.user_data.update(state="ROSSETI_YUG", is_rosseti_yug=True)
            # show submenu...
        elif text == "‚ö°Ô∏è –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å":
            context.user_data.update(state="ROSSETI_KUBAN", is_rosseti_yug=False)
        elif text == "üìä –í—ã–≥—Ä—É–∑–∏—Ç—å –æ—Ç—á–µ—Ç—ã":
            context.user_data["state"] = "REPORT_MENU"
            await update.message.reply_text(
                "üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ—Ç—á—ë—Ç–∞:",
                reply_markup=build_menu(REPORT_SUBMENU, ud),
            )
            return REPORT_MENU
        elif text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
            return await start(update, context)
        # ... other MAIN_MENU items
        return ConversationHandler.END

    # REPORT_MENU
    if state == "REPORT_MENU":
        if text == "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –Æ–ì":
            df = pd.read_csv(NOTIFY_LOG_FILE_UG)
            bio = io.BytesIO()
            with pd.ExcelWriter(bio, engine="openpyxl") as writer:
                df.to_excel(writer, index=False, sheet_name="UG")
            bio.seek(0)
            await update.message.reply_document(bio, filename="log_ug.xlsx")
        elif text == "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –ö—É–±–∞–Ω—å":
            df = pd.read_csv(NOTIFY_LOG_FILE_RK)
            bio = io.BytesIO()
            with pd.ExcelWriter(bio, engine="openpyxl") as writer:
                df.to_excel(writer, index=False, sheet_name="RK")
            bio.seek(0)
            await update.message.reply_document(bio, filename="log_rk.xlsx")
        elif text == "üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤":
            await update.message.reply_text(
                "üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤ ‚Äî —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç!",
                reply_markup=build_menu(REPORT_SUBMENU, ud),
            )
        elif text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
            context.user_data["state"] = "MAIN_MENU"
            await update.message.reply_text(
                "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=build_menu(MAIN_MENU, ud)
            )
            return ConversationHandler.END
        # stay in REPORT_MENU for further selections
        return REPORT_MENU

    # ... other states handlers (TP search, notify, etc.)
    return ConversationHandler.END

async def error_handler(
    update: Any, context: ContextTypes.DEFAULT_TYPE
) -> None:
    logger.error(f"Update {update} caused error {context.error}")

# FastAPI endpoints and startup/shutdown
@app.post("/webhook")
async def webhook(request: Request) -> Dict[str, str]:
    upd = Update.de_json(await request.json(), application.bot)
    if upd:
        await application.process_update(upd)
    return {"status": "ok"}

@app.on_event("startup")
async def on_startup() -> None:
    app.state.http = httpx.AsyncClient()
    global application
    application = Application.builder().token(TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    conv = ConversationHandler(
        entry_points=[MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)],
        states={
            SEARCH_TP: [MessageHandler(filters.TEXT & ~filters.COMMAND, /*...*/)],
            SELECT_TP: [MessageHandler(filters.TEXT & ~filters.COMMAND, /*...*/)],
            NOTIFY_TP: [MessageHandler(filters.TEXT & ~filters.COMMAND, /*...*/)],
            NOTIFY_VL: [MessageHandler(filters.TEXT & ~filters.COMMAND, /*...*/)],
            NOTIFY_GEO: [MessageHandler(filters.LOCATION, /*...*/)],
            REPORT_MENU: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)],
        },
        fallbacks=[CommandHandler("cancel", start)],
    )
    application.add_handler(conv)
    application.add_error_handler(error_handler)
    await application.initialize()
    webhook_url = f"{SELF_URL}/webhook"
    await application.bot.set_webhook(webhook_url)

@app.on_event("shutdown")
async def on_shutdown() -> None:
    await application.stop()
    await app.state.http.aclose()

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=PORT)
