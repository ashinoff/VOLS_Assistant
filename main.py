import logging
import io
import re
from functools import lru_cache
from typing import Any, Dict, List, Optional, Tuple

import pandas as pd
import httpx
import uvicorn
from fastapi import FastAPI, Request
from telegram import (
    Update,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    KeyboardButton,
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)
from config import (
    TOKEN,
    ZONES_CSV_URL,
    SELF_URL,
    PORT,
    # URLs for TP data
    YUGO_ZAPAD_URL_UG,
    CENTRAL_URL_UG,
    ZAPAD_URL_UG,
    VOSTOCH_URL_UG,
    YUZH_URL_UG,
    SEVERO_VOSTOCH_URL_UG,
    YUGO_VOSTOCH_URL_UG,
    SEVER_URL_UG,
    YUGO_ZAPAD_URL_RK,
    UST_LABINSK_URL_RK,
    TIMASHEVSK_URL_RK,
    TIKHORETSK_URL_RK,
    SOCHI_URL_RK,
    SLAVYANSK_URL_RK,
    LENINGRADSK_URL_RK,
    LABINSK_URL_RK,
    KRASNODAR_URL_RK,
    ARMAVIR_URL_RK,
    ADYGEYSK_URL_RK,
    # URLs for notification directory
    YUGO_ZAPAD_URL_UG_SP,
    CENTRAL_URL_UG_SP,
    ZAPAD_URL_UG_SP,
    VOSTOCH_URL_UG_SP,
    YUZH_URL_UG_SP,
    SEVERO_VOSTOCH_URL_UG_SP,
    YUGO_VOSTOCH_URL_UG_SP,
    SEVER_URL_UG_SP,
    YUGO_ZAPAD_URL_RK_SP,
    UST_LABINSK_URL_RK_SP,
    TIMASHEVSK_URL_RK_SP,
    TIKHORETSK_URL_RK_SP,
    SOCHI_URL_RK_SP,
    SLAVYANSK_URL_RK_SP,
    LENINGRADSK_URL_RK_SP,
    LABINSK_URL_RK_SP,
    KRASNODAR_URL_RK_SP,
    ARMAVIR_URL_RK_SP,
    ADYGEYSK_URL_RK_SP,
    # Report files
    NOTIFY_LOG_FILE_UG,
    NOTIFY_LOG_FILE_RK,
)

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# FastAPI app placeholder; Telegram application initialized on startup
app = FastAPI()
application: Application

# Conversation states
(
    SEARCH_TP,
    SELECT_TP,
    NOTIFY_TP,
    NOTIFY_VL,
    NOTIFY_GEO,
    REPORT_MENU,
) = range(6)

# ES URL mappings
ES_URL_MAPPING: Dict[str, str] = {
    "–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°_UG": YUGO_ZAPAD_URL_UG,
    "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –≠–°": CENTRAL_URL_UG,
    "–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°": ZAPAD_URL_UG,
    "–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": VOSTOCH_URL_UG,
    "–Æ–∂–Ω—ã–µ –≠–°": YUZH_URL_UG,
    "–°–µ–≤–µ—Ä–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": SEVERO_VOSTOCH_URL_UG,
    "–Æ–≥–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°": YUGO_VOSTOCH_URL_UG,
    "–°–µ–≤–µ—Ä–Ω—ã–µ –≠–°": SEVER_URL_UG,
    "–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°_RK": YUGO_ZAPAD_URL_RK,
    "–£—Å—Ç—å-–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°": UST_LABINSK_URL_RK,
    "–¢–∏–º–∞—à–µ–≤—Å–∫–∏–µ –≠–°": TIMASHEVSK_URL_RK,
    "–¢–∏—Ö–æ—Ä–µ—Ü–∫–∏–µ –≠–°": TIKHORETSK_URL_RK,
    "–°–æ—á–∏–Ω—Å–∫–∏–µ –≠–°": SOCHI_URL_RK,
    "–°–ª–∞–≤—è–Ω—Å–∫–∏–µ –≠–°": SLAVYANSK_URL_RK,
    "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∏–µ –≠–°": LENINGRADSK_URL_RK,
    "–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°": LABINSK_URL_RK,
    "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–µ –≠–°": KRASNODAR_URL_RK,
    "–ê—Ä–º–∞–≤–∏—Ä—Å–∫–∏–µ –≠–°": ARMAVIR_URL_RK,
    "–ê–¥—ã–≥–µ–π—Å–∫–∏–µ –≠–°": ADYGEYSK_URL_RK,
}
ES_SP_URL_MAPPING: Dict[str, str] = {**ES_URL_MAPPING}
ES_SP_URL_MAPPING.update({
    k.replace("_UG", "_UG_SP").replace("_RK", "_RK_SP"): v for k, v in ES_URL_MAPPING.items()
})

# Main menu
MAIN_MENU = [
    {"text": "‚ö°Ô∏è –†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "vis": "all"},
    {"text": "‚ö°Ô∏è –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å", "vis": "all"},
    {"text": "üìä –í—ã–≥—Ä—É–∑–∏—Ç—å –æ—Ç—á–µ—Ç—ã", "vis": "all"},
    {"text": "üìû –¢–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫", "vis": "all"},
    {"text": "üìñ –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", "vis": "all"},
    {"text": "üìö –°–ø—Ä–∞–≤–∫–∞", "vis": "all"},
    {"text": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "vis": "all"},
]
# ES submenu
ES_SUBMENU = [
    {"text": "üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü", "vis": "all"},
    {"text": "üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ", "vis": "all"},
    {"text": "üìö –°–ø—Ä–∞–≤–∫–∞", "vis": "all"},
    {"text": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "vis": "all"},
]
# Report submenu
REPORT_SUBMENU = [
    {"text": "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –Æ–ì", "vis": "all"},
    {"text": "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –ö—É–±–∞–Ω—å", "vis": "all"},
    {"text": "üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤", "vis": "all"},
    {"text": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "vis": "all"},
]

# Utility: build keyboard based on visibility
def build_menu(
    buttons: List[Dict[str, str]], user_data: Dict[str, Any]
) -> ReplyKeyboardMarkup:
    keyboard = [[btn["text"]] for btn in buttons if has_access(user_data, btn["vis"])]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True) if keyboard else ReplyKeyboardRemove()

@lru_cache(maxsize=1)
def load_user_data() -> Dict[str, Dict[str, Any]]:
    users: Dict[str, Dict[str, Any]] = {}
    try:
        df = pd.read_csv(ZONES_CSV_URL, encoding="utf-8")
        for _, row in df.iterrows():
            uid = str(row["Telegram ID"])
            users[uid] = {
                "Visibility": row["–í–∏–¥–∏–º–æ—Å—Ç—å"],
                "Branch": row["–§–∏–ª–∏–∞–ª"],
                "RES": row["–†–≠–°"],
                "FIO": row["–§–ò–û"],
                "Responsible": row["–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π"],
            }
    except Exception as e:
        logger.error(f"Error loading user data: {e}")
    return users

def has_access(user_data: Dict[str, Any], required_vis: str) -> bool:
    uv = user_data.get("Visibility", "").lower()
    return uv == "all" or required_vis == "all" or uv == required_vis.lower()

# Async data loaders
def _get_url_key(es_name: str, is_ug: bool) -> str:
    suffix = "_UG" if is_ug else "_RK"
    return es_name if not es_name.startswith("–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°") else f"–Æ–≥–æ-–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°{suffix}"

async def load_tp_data(es_name: str, is_ug: bool) -> pd.DataFrame:
    url = ES_URL_MAPPING.get(_get_url_key(es_name, is_ug), "")
    if not url:
        return pd.DataFrame()
    resp = await app.state.http.get(url)
    resp.raise_for_status()
    return pd.read_csv(io.StringIO(resp.text), encoding="utf-8")

async def load_tp_directory_data(es_name: str, is_ug: bool) -> pd.DataFrame:
    url = ES_SP_URL_MAPPING.get(_get_url_key(es_name, is_ug), "")
    if not url:
        return pd.DataFrame()
    resp = await app.state.http.get(url)
    resp.raise_for_status()
    return pd.read_csv(io.StringIO(resp.text), encoding="utf-8")

# Search and notify logic
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    uid = str(update.effective_user.id)
    ud = load_user_data().get(uid)
    if not ud:
        await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END
    context.user_data.clear()
    context.user_data.update(state="MAIN_MENU")
    await update.message.reply_text(
        f"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {ud['FIO']}! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=build_menu(MAIN_MENU, ud),
    )
    return ConversationHandler.END

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    uid = str(update.effective_user.id)
    ud = load_user_data().get(uid)
    text = update.message.text
    state = context.user_data.get("state", "MAIN_MENU")

    if state == "MAIN_MENU":
        if text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
            return await start(update, context)
        if text in [b["text"] for b in MAIN_MENU]:
            if text.startswith("‚ö°Ô∏è –†–æ—Å—Å–µ—Ç–∏"):
                context.user_data.update(
                    state="ES_SUBMENU",
                    selected_es=text.replace("‚ö°Ô∏è ", ""),
                    is_ug=text.endswith("–Æ–ì"),
                )
                await update.message.reply_text(
                    f"–í—ã –≤—ã–±—Ä–∞–ª–∏ {context.user_data['selected_es']}.",
                    reply_markup=build_menu(ES_SUBMENU, ud),
                )
                return ConversationHandler.END
            if text == "üìä –í—ã–≥—Ä—É–∑–∏—Ç—å –æ—Ç—á–µ—Ç—ã":
                context.user_data["state"] = "REPORT_MENU"
                await update.message.reply_text(
                    "üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ—Ç—á—ë—Ç–∞:",
                    reply_markup=build_menu(REPORT_SUBMENU, ud),
                )
                return REPORT_MENU
    elif state == "REPORT_MENU":
        if text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
            context.user_data["state"] = "MAIN_MENU"
            await update.message.reply_text(
                "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=build_menu(MAIN_MENU, ud)
            )
            return ConversationHandler.END
        if text == "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –Æ–ì":
            df = pd.read_csv(NOTIFY_LOG_FILE_UG)
            bio = io.BytesIO()
            with pd.ExcelWriter(bio, engine="openpyxl") as w:
                df.to_excel(w, index=False, sheet_name="UG")
            bio.seek(0)
            await update.message.reply_document(bio, filename="log_ug.xlsx")
        elif text == "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –ö—É–±–∞–Ω—å":
            df = pd.read_csv(NOTIFY_LOG_FILE_RK)
            bio = io.BytesIO()
            with pd.ExcelWriter(bio, engine="openpyxl") as w:
                df.to_excel(w, index=False, sheet_name="RK")
            bio.seek(0)
            await update.message.reply_document(bio, filename="log_rk.xlsx")
        elif text == "üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤":
            await update.message.reply_text(
                "üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤ ‚Äî —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç!",
                reply_markup=build_menu(REPORT_SUBMENU, ud),
            )
        return REPORT_MENU

    # ES_SUBMENU
    if context.user_data.get("state") == "ES_SUBMENU":
        es = context.user_data["selected_es"]
        if text == "üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü":
            await update.message.reply_text(
                f"–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ {es}:",
                reply_markup=ReplyKeyboardRemove(),
            )
            return SEARCH_TP
        if text == "üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ":
            await update.message.reply_text(
                f"–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ {es}:",
                reply_markup=ReplyKeyboardRemove(),
            )
            return NOTIFY_TP
        if text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
            return await start(update, context)

    return ConversationHandler.END

async def search_tp(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    uid = str(update.effective_user.id)
    ud = load_user_data().get(uid)
    term = update.message.text
    es = context.user_data.get("selected_es")
    df = await load_tp_data(es, context.user_data.get("is_ug", False))
    if df.empty:
        await update.message.reply_text("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö.", reply_markup=build_menu(ES_SUBMENU, ud))
        context.user_data["state"] = "ES_SUBMENU"
        return ConversationHandler.END
    exact = df[df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"] == term]
    if not exact.empty:
        await send_tp_results(update, context, exact)
        context.user_data["state"] = "ES_SUBMENU"
        await update.message.reply_text("–ì–æ—Ç–æ–≤–æ.", reply_markup=build_menu(ES_SUBMENU, ud))
        return ConversationHandler.END
    options = fuzzy_search_tp(term, df)
    if not options:
        await update.message.reply_text(
            f"–¢–ü '{term}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", reply_markup=ReplyKeyboardRemove()
        )
        return SEARCH_TP
    context.user_data["tp_options"] = options
    kb = ReplyKeyboardMarkup([[o] for o in options] + [["‚¨ÖÔ∏è –ù–∞–∑–∞–¥"]], resize_keyboard=True)
    await update.message.reply_text("–ü–æ—Ö–æ–∂–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:", reply_markup=kb)
    return SELECT_TP

async def select_tp(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    uid = str(update.effective_user.id)
    ud = load_user_data().get(uid)
    choice = update.message.text
    if choice == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        context.user_data["state"] = "ES_SUBMENU"
        return ConversationHandler.END
    es = context.user_data.get("selected_es")
    df = await load_tp_data(es, context.user_data.get("is_ug", False))
    sel = df[df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"] == choice]
    await send_tp_results(update, context, sel)
    context.user_data["state"] = "ES_SUBMENU"
    await update.message.reply_text("–ì–æ—Ç–æ–≤–æ.", reply_markup=build_menu(ES_SUBMENU, ud))
    return ConversationHandler.END

async def notify_tp(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    uid = str(update.effective_user.id)
    ud = load_user_data().get(uid)
    term = update.message.text
    es = context.user_data.get("selected_es")
    df = await load_tp_directory_data(es, context.user_data.get("is_ug", False))
    if df.empty:
        await update.message.reply_text("–û—à–∏–±–∫–∞ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞.", reply_markup=build_menu(ES_SUBMENU, ud))
        return ConversationHandler.END
    exact = df[df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"] == term]
    if not exact.empty:
        context.user_data["tp_options"] = [term]
        context.user_data["vl_options"] = exact["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ"].dropna().unique().tolist()
        kb = ReplyKeyboardMarkup([[v] for v in context.user_data["vl_options"]] + [["‚¨ÖÔ∏è –ù–∞–∑–∞–¥"]], resize_keyboard=True)
        await update.message.reply_text(f"–í—ã–±–µ—Ä–∏—Ç–µ –í–õ –¥–ª—è {term}:", reply_markup=kb)
        return NOTIFY_VL
    opts = fuzzy_search_tp(term, df)
    if not opts:
        await update.message.reply_text(f"–¢–ü '{term}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", reply_markup=ReplyKeyboardRemove())
        return NOTIFY_TP
    context.user_data["tp_options"] = opts
    kb = ReplyKeyboardMarkup([[o] for o in opts] + [["‚¨ÖÔ∏è –ù–∞–∑–∞–¥"]], resize_keyboard=True)
    await update.message.reply_text("–ü–æ—Ö–æ–∂–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:", reply_markup=kb)
    return NOTIFY_TP

async def notify_vl(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    choice = update.message.text
    if choice == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        return await handle_message(update, context)
    context.user_data["selected_vl"] = choice
    kb = ReplyKeyboardMarkup([[KeyboardButton("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ", request_location=True)]], resize_keyboard=True)
    await update.message.reply_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ:", reply_markup=kb)
    return NOTIFY_GEO

async def notify_geo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    loc = update.message.location
    es = context.user_data.get("selected_es")
    tp = context.user_data.get("tp_options", [None])[0]
    vl = context.user_data.get("selected_vl")
    df = await load_tp_directory_data(es, context.user_data.get("is_ug", False))
    row = df[(df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"] == tp) & (df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ"] == vl)]
    res = row["–†–≠–°"].iloc[0] if not row.empty else None
    users = load_user_data()
    uid_resp, fio_resp = find_responsible(res, users)
    if not uid_resp:
        await update.message.reply_text("–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=build_menu(ES_SUBMENU, users[str(update.effective_user.id)]))
        return ConversationHandler.END
    msg = f"‚ö†Ô∏è –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ: –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω–∞—è –í–û–õ–° {tp}, {vl}, –†–≠–° {res}"
    await application.bot.send_message(uid_resp, msg)
    await application.bot.send_location(uid_resp, loc.latitude, loc.longitude)
    # Log
    with open(NOTIFY_LOG_FILE_UG if context.user_data.get("is_ug") else NOTIFY_LOG_FILE_RK, "a", encoding="utf-8") as f:
        f.write(f"{es},{tp},{vl},{loc.latitude},{loc.longitude}\n")
    await update.message.reply_text("–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.", reply_markup=build_menu(ES_SUBMENU, users[str(update.effective_user.id)]))
    return ConversationHandler.END

async def send_tp_results(update: Update, context: ContextTypes.DEFAULT_TYPE, df: pd.DataFrame) -> None:
    res = df["–†–≠–°"].iloc[0] if not df.empty else ""
    tp = context.user_data.get("tp_options", [None])[0]
    await update.message.reply_text(f"–í {res} –Ω–∞ –¢–ü {tp} –Ω–∞–π–¥–µ–Ω–æ {len(df)} –í–û–õ–°:")
    for _, r in df.iterrows():
        await update.message.reply_text(
            f"üìç –í–õ: {r['–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ']}\n"
            f"–û–ø–æ—Ä—ã: {r['–û–ø–æ—Ä—ã']}\n"
            f"–ö–æ–ª-–≤–æ: {r['–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–æ—Ä']}"
        )

async def error_handler(update: Any, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(f"Update {update} caused error {context.error}")

@app.post("/webhook")
async def webhook(request: Request) -> Dict[str, str]:
    upd = Update.de_json(await request.json(), application.bot)
    if upd:
        await application.process_update(upd)
    return {"status": "ok"}

@app.on_event("startup")
async def on_startup() -> None:
    app.state.http = httpx.AsyncClient()
    global application
    application = Application.builder().token(TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    conv = ConversationHandler(
        entry_points=[MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)],
        states={
            SEARCH_TP: [MessageHandler(filters.TEXT & ~filters.COMMAND, search_tp)],
            SELECT_TP: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_tp)],
            NOTIFY_TP: [MessageHandler(filters.TEXT & ~filters.COMMAND, notify_tp)],
            NOTIFY_VL: [MessageHandler(filters.TEXT & ~filters.COMMAND, notify_vl)],
            NOTIFY_GEO: [MessageHandler(filters.LOCATION, notify_geo)],
            REPORT_MENU: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)],
        },
        fallbacks=[CommandHandler("cancel", start)],
    )
    application.add_handler(conv)
    application.add_error_handler(error_handler)
    await application.initialize()
    await application.bot.set_webhook(f"{SELF_URL}/webhook")

@app.on_event("shutdown")
async def on_shutdown() -> None:
    await application.stop()
    await app.state.http.aclose()

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=PORT)
